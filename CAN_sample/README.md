Renesas RX62N, RX631, RX64M, RX71M, RX66T, RX72N CAN sample
=========

[Japanese](READMEja.md)
   
## Overview

Sample program for CAN communication using RX microcontroller   
A CAN bus transceiver has to be connected to the CAN port.   
If there are multiple channels of CAN, the communication channel is switched.   
The environment variable "MULTI" is enabled in "main.cpp".

## Description
- main.cpp
- RX62N/Makefile
- RX631/Makefile
- RX64M/Makefile
- RX71M/Makefile
- RX66T/Makefile
- RX72T/Makefile
- RX72N/Makefile
- README.md
- READMEja.md

## Hardware preparation

- If the base crystal is different, change the typedef parameters.
- The RXxxx/clock_profile.hpp declares a set frequency for each module.
- Connect the LED to the specified port.
- In the case of the RX72N Envision kit, it utilizes the blue LED on the board.
- Connect the CAN bus transceiver to the CAN port. (CTX0, CRX0)
- Connect the appropriate terminator resistor to the CAN bus transceiver.
- The CAN bus transceiver must be of the 3.3 V operating variety.
   
### CAN port setting

See the following sources for the ports to connect the CAN bus transceiver.

|microcontroller|file|CAN0 Alternate|CAN1 Alternate|
|-------|--------|:---:|:---:|
|RX62N  |[RX62x/port_map.hpp](../RX62x/port_map.hpp)|FIRST|X|
|RX631  |[RX63x/port_map.hpp](../RX63x/port_map.hpp)|FIRST|-|
|RX64M  |[RX600/port_map.hpp](../RX600/port_map.hpp)|FIRST|FIRST|
|RX71M  |[RX600/port_map.hpp](../RX600/port_map.hpp)|FIRST|FIRST|
|RX66T  |[RX66T/port_map.hpp](../RX66T/port_map.hpp)|FIRST|X|
|RX72T  |[RX72T/port_map.hpp](../RX72T/port_map.hpp)|FIRST|X|
|RX72N  |[RX72N/port_map.hpp](../RX72N/port_map.hpp)|X|SECOND|
   
For RX64M (port_map.hpp FIRST candidate)
```C++
            case peripheral::CAN0:
                {
                    uint8_t sel = enable ? 0b010000 : 0;
                    PORT3::PMR.B2 = 0;
                    PORT3::PMR.B3 = 0;
                    MPC::P32PFS.PSEL = sel;  // CTX0 (P32 LQFP176: 29)
                    MPC::P33PFS.PSEL = sel;  // CRX0 (P33 LQFP176: 28)
                    PORT3::PMR.B2 = enable;
                    PORT3::PMR.B3 = enable;
                }
                break;
```

- By changing the CAN port candidate in main.cpp, the assigned port can be changed.
- Basic port settings are prepared in port_map.hpp.

```
    static const auto CAN0_PORT = device::port_map::option::FIRST;
    static const auto CAN1_PORT = device::port_map::option::FIRST;
```

---

### Typical varieties of CAN bus transceivers

[Texas Instruments: SN65HVD23x](https://www.ti.com/lit/ds/symlink/sn65hvd234.pdf?ts=1604192672378&ref_url=https%253A%252F%252Fwww.google.com%252F)
- Candidate for operation at 3.3V

[NXP Semiconductors: TJA1441](https://www.nxp.com/docs/en/data-sheet/TJA1441.pdf)
- Power 5V
- I/O 3.3V、5V selectable
- Max 5 Mbit/s

---

### In the case of RX64M/RX71M

- Multi-channel support
   
### In the case of the RX66T/RX72T

- single channel

### In the case of the RX72N Envision Kit

- The program supports multiple channels, but it is a single channel because it does not have access to the CAN port.
- Use CAN1
- Pmod1  (1) P54_SS    (CTX1)
- Pmod1  (7) P55/IRQ10 (CRX1)
- Pmod1  (6) 3.3V
- Pmod1 (12) 3.3V
- Pmod1  (5) GND
- Pmod1 (11) GND

---

## CAN/ID Filters

main.cpp contains sample code for a filter with a list of IDs that can be passed through.   
This function is used for the "MULTI" channel.   
   
This filter uses "boost/unordered_set".   
   
If you comment out "#define VALID_FILTER" at the beginning of main.cpp, the filter is passed through.   
   
A valid ID table looks like this   

```
	// 有効な ID だけ通すフィルター
	typedef boost::unordered_set<uint32_t> VALID;
//	typedef const boost::unordered_set<uint32_t> VALID;
	VALID	valid_{ 0x123, 0x200, 0x300, 0xaaa, 15, 21, 33 };
```
   
In the main loop, when dispatching the incoming frame of CAN1, check if the ID is valid and ignore invalid IDs.
   
```
		while(can1_.get_recv_num() > 0) {
			auto frm = can1_.get_recv_frame();
#ifdef VALID_FILTER
			if(valid_.find(frm.get_id()) != valid_.end()) {
#else
			{
#endif
				utils::format("\nCAN1:\n");
				CAN::list(frm, "  ");
			}
		}
```

---

## Resource preparation
- None
   
## How to build

- Move to each platform directory and make it.
- Write the led_sample.mot file.
   
## Operation

- The LED flashes every 0.25 seconds.
- The terminal makes a serial connection and communicates with interactive commands.
   
## Dialogue Commands

In an interactive manner, you can send and receive CAN data.

- When you start the program, it always receives all IDs.
- If the number of IDs exceeds the limit, the program may crash due to lack of memory.
- The send_loop command continuously sends IDs and data generated by random numbers.
- A function to supplement the IDs (map) is provided for channel 0 only.
- On the RX64M/RX71M, two channels of CAN are enabled.
- Receiving CAN1 (two channels) always displays the data received.
- MB-no is the number of the mailbox.
- The commands related to the mailbox are for debugging.

Translated with www.DeepL.com/Translator (free version)

 ```
    ch CH-no               set current CAN channel (CH-no: 0, 1)
    send CAN-ID [data...]  send data frame
    stat MB-no             stat mail-box (MB-no: 0 to 31)
    list MB-no             list mail-box (MB-no: 0 to 31)
    map [CAN-ID]           Display all collected IDs
    clear                  clear map
    dump CAN-ID            dump frame data
    send_loop NUM          random ID, random DATA, send loop
    help                   command list (this)
``` 
   
-----
   
License
----

[MIT](../LICENSE)
